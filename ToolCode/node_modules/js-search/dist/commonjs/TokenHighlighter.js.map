{"version":3,"sources":["../../source/TokenHighlighter.js"],"names":["TokenHighlighter","opt_indexStrategy","opt_sanitizer","opt_wrapperTagName","_indexStrategy","_sanitizer","_wrapperTagName","text","tokens","tagsLength","_wrapText","length","tokenDictionary","i","numTokens","token","sanitize","expandedTokens","expandToken","j","numExpandedTokens","expandedToken","push","actualCurrentWord","sanitizedCurrentWord","currentWordStartIndex","textLength","character","charAt","indexOf","substring","tagName"],"mappings":";;;;;;;;;AAEA;;AACA;;;;AAKA;;;;;;IAMaA,gB,WAAAA,gB;;AAKX;;;;;;;AAOA,4BAAYC,iBAAZ,EAAgDC,aAAhD,EAA4EC,kBAA5E,EAAuG;AAAA;;AACrG,SAAKC,cAAL,GAAsBH,qBAAqB,gCAA3C;AACA,SAAKI,UAAL,GAAkBH,iBAAiB,gCAAnC;AACA,SAAKI,eAAL,GAAuBH,sBAAsB,MAA7C;AACD;;AAED;;;;;;;;;;;8BAOUI,I,EAAeC,M,EAAwB;AAC/C,UAAIC,aAAsB,KAAKC,SAAL,CAAe,EAAf,EAAmBC,MAA7C;;AAEA,UAAIC,kBAAkB,EAAtB;;AAEA;AACA,WAAK,IAAIC,IAAI,CAAR,EAAWC,YAAYN,OAAOG,MAAnC,EAA2CE,IAAIC,SAA/C,EAA0DD,GAA1D,EAA+D;AAC7D,YAAIE,QAAiB,KAAKV,UAAL,CAAgBW,QAAhB,CAAyBR,OAAOK,CAAP,CAAzB,CAArB;AACA,YAAII,iBAAiC,KAAKb,cAAL,CAAoBc,WAApB,CAAgCH,KAAhC,CAArC;;AAEA,aAAK,IAAII,IAAI,CAAR,EAAWC,oBAAoBH,eAAeN,MAAnD,EAA2DQ,IAAIC,iBAA/D,EAAkFD,GAAlF,EAAuF;AACrF,cAAIE,gBAAyBJ,eAAeE,CAAf,CAA7B;;AAEA,cAAI,CAACP,gBAAgBS,aAAhB,CAAL,EAAqC;AACnCT,4BAAgBS,aAAhB,IAAiC,CAACN,KAAD,CAAjC;AACD,WAFD,MAEO;AACLH,4BAAgBS,aAAhB,EAA+BC,IAA/B,CAAoCP,KAApC;AACD;AACF;AACF;;AAED;AACA,UAAIQ,oBAA6B,EAAjC;AACA,UAAIC,uBAAgC,EAApC;AACA,UAAIC,wBAAiC,CAArC;;AAEA;AACA,WAAK,IAAIZ,IAAI,CAAR,EAAWa,aAAanB,KAAKI,MAAlC,EAA0CE,IAAIa,UAA9C,EAA0Db,GAA1D,EAA+D;AAC7D,YAAIc,YAAqBpB,KAAKqB,MAAL,CAAYf,CAAZ,CAAzB;;AAEA,YAAIc,cAAc,GAAlB,EAAuB;AACrBJ,8BAAoB,EAApB;AACAC,iCAAuB,EAAvB;AACAC,kCAAwBZ,IAAI,CAA5B;AACD,SAJD,MAIO;AACLU,+BAAqBI,SAArB;AACAH,kCAAwB,KAAKnB,UAAL,CAAgBW,QAAhB,CAAyBW,SAAzB,CAAxB;AACD;;AAED,YAAIf,gBAAgBY,oBAAhB,KACFZ,gBAAgBY,oBAAhB,EAAsCK,OAAtC,CAA8CL,oBAA9C,KAAuE,CADzE,EAC4E;;AAE1ED,8BAAoB,KAAKb,SAAL,CAAea,iBAAf,CAApB;AACAhB,iBAAOA,KAAKuB,SAAL,CAAe,CAAf,EAAkBL,qBAAlB,IAA2CF,iBAA3C,GAA+DhB,KAAKuB,SAAL,CAAejB,IAAI,CAAnB,CAAtE;;AAEAA,eAAKJ,UAAL;AACAiB,wBAAcjB,UAAd;AACD;AACF;;AAED,aAAOF,IAAP;AACD;;AAED;;;;;;;;8BAKUA,I,EAAwB;AAChC,UAAMwB,UAAU,KAAKzB,eAArB;AACA,mBAAWyB,OAAX,SAAsBxB,IAAtB,UAA+BwB,OAA/B;AACD;;;;;;AACF","file":"TokenHighlighter.js","sourcesContent":["// @flow\n\nimport { PrefixIndexStrategy } from './IndexStrategy/index';\nimport { LowerCaseSanitizer } from './Sanitizer/index';\n\nimport type { IIndexStrategy } from './IndexStrategy/index';\nimport type { ISanitizer } from './Sanitizer/index';\n\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\nexport class TokenHighlighter {\n  _indexStrategy : IIndexStrategy;\n  _sanitizer : ISanitizer\n  _wrapperTagName : string;\n\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  constructor(opt_indexStrategy : IIndexStrategy, opt_sanitizer : ISanitizer, opt_wrapperTagName:string) {\n    this._indexStrategy = opt_indexStrategy || new PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n  highlight(text : string, tokens : Array<string>) {\n    var tagsLength : number = this._wrapText('').length;\n\n    var tokenDictionary = {};\n\n    // Create a token map for easier lookup below.\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token : string = this._sanitizer.sanitize(tokens[i]);\n      var expandedTokens : Array<string> = this._indexStrategy.expandToken(token);\n\n      for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n        var expandedToken : string = expandedTokens[j];\n\n        if (!tokenDictionary[expandedToken]) {\n          tokenDictionary[expandedToken] = [token];\n        } else {\n          tokenDictionary[expandedToken].push(token);\n        }\n      }\n    }\n\n    // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n    var actualCurrentWord : string = '';\n    var sanitizedCurrentWord : string = '';\n    var currentWordStartIndex : number = 0;\n\n    // Note this assumes either prefix or full word matching.\n    for (var i = 0, textLength = text.length; i < textLength; i++) {\n      var character : string = text.charAt(i);\n\n      if (character === ' ') {\n        actualCurrentWord = '';\n        sanitizedCurrentWord = '';\n        currentWordStartIndex = i + 1;\n      } else {\n        actualCurrentWord += character;\n        sanitizedCurrentWord += this._sanitizer.sanitize(character);\n      }\n\n      if (tokenDictionary[sanitizedCurrentWord] &&\n        tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n\n        actualCurrentWord = this._wrapText(actualCurrentWord);\n        text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n\n        i += tagsLength;\n        textLength += tagsLength;\n      }\n    }\n\n    return text;\n  }\n\n  /**\n   * @param text to wrap\n   * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n   * @private\n   */\n  _wrapText(text : string) : string {\n    const tagName = this._wrapperTagName;\n    return `<${tagName}>${text}</${tagName}>`;\n  }\n};\n"]}